---
layout: layouts/post.njk
title: >
      RR 317: Computer Science at University and the Future of Programming with Dave Thomas
date: 2017-07-04 05:00:21
episode_number: 317
duration: 54:11
audio_url: https://media.devchat.tv//ruby-rogues/RR_317_Computer_Science_at_University_and_the_Future_of_Programming_with_Dave_Thomas_mixdown.mp3
podcast: ruby-rogues
tags: 
  - ruby_rogues
  - podcast
---

<h2>RR 317: Computer Science at University and the Future of Programming with Dave Thomas</h2>
Charles Max Wood interviews Dave Thomas about the Computer Science course he's teaching at Southern Methodist University, Elixir, and the future of programming. Dave is the author and co-author of several well known programming books including Programming Ruby (also known as the PickAxe Book), Programming Elixir, and the Pragmatic Programmer. This episode starts out discussing Dave's course and Computer Science education, then veers into Elixir and the future of programming. Tune in to hear where Dave thinks the programming industry is heading next.

<strong>[00:02:30] Dave's Computer Science Course at SMU </strong>
Dave's advanced computer science course covers topics like source control and testing. He's been wanting to get into formal Computer Science for a while, so when he pulled back on his work at the Pragmatic Bookshelf, he approached SMU about teaching a course. He selected Advanced Application Development since he could teach pretty much whatever he wanted. The class is made up of Seniors and Master's students whose coursework primarily focused on theory, but lacked in the basics of coding as it happens "in the wild." The plan was to go in and subvert them with Elixir.

All of the assignments are coding assignments and must be submitted with a pull request. Chuck recalls taking a class similar to the one that Dave describes.

<strong>[00:06:22] Computer Science's focus on theory</strong>
People who go into academia generally get their degrees and don't spend any time in the non-academic world. So, they don't know what's important when it comes down to nuts and bolts programming. This serves the students that stay in academia, but fails to teach the skills needed by their students. They also focus on the mathematical aspects of Computer Science and fail to show students that if they get excited about software, it can be fun.

<strong>[00:09:55] This is a job where we make a difference</strong>
Sometimes we do great harm. and sometimes great good.

<strong>[00:10:23] How do you communicate all of these aspects of coding to the students?</strong>
You can't just tell them. Mostly, Dave just tries to be enthusiastic. The teaching as it's done now is like a eulogy given by someone who doesn't know the person. Instead, Dave shows his passion for coding, tells stories, and shows how fun it is to write code. Imagine walking down the street and seeing the code you wrote being used. Dave's code was used on the satellite sent to see Haley's Comet.

<strong>[00:13:04] Software as a tool for change</strong>
A painter's medium is paint. Sculptors' stone. People in software don't "write" per se, but they still express themselves. This is a medium for programmers to get their thoughts out and interact with other people all over the world. We do a really crappy job explaining this to students.

Dave is involved in after-school programs for software development as well. The ones that succeed don't approach software head on. They do fun and fancy stuff with Raspberry Pi or put a webserver up and then point out the concepts used in the programming. This approach is the future of development training.

<strong>[00:16:01] Do you feel like CS programs aren't preparing students well? or have the wrong focus?</strong>
Students come out well versed in the theoretics of programming and can write programs. These are good things to know. The assumption is that they'll pick up the rest in their first couple of jobs. They're not preparing people to walk straight into a job, but prepares them to learn the rest on the job.

A 4 year program should be done after 2 years working in the real world. Most of the things not taught don't make sense until the student has the problem that it solves. For example, source control. This would give them context for the things that are important and bring the knowledge back to the

<strong>[00:20:26] What is in the curriculum?
</strong>In a few years, these students will probably be writing a functional language like Elixir. They start out writing a hangman game using Elixir. Then they add Phoenix. Then they add a webserver. The focus is around the fact that what you care about is state and transformations. Then someone will realize that you're really just implementing objects. Dave is trying to teach how to think in decoupled services.

<strong>[00:22:28] The future is functional?</strong>
Elixir is a practical functional language and solves some problems that programmers have been trying to solve for a long time. Clojure has a strange relationship with the JVM. Elixir is not as cleanly functional as other languages, but it's functional enough. At the same time, you can write kick-ass web services as well. You also get the power of the Erlang virtual machine.

Looking at Moore's Law, why aren't our processors getting faster? Over the last 10 years, they're not that much faster and the next generations are slower. But they have more cores. If you double the clock speed, you 8x the power dissipation. So, there's a limit to how fast you can go before you melt the processor. So, you run more cores at a lower speed. This vastly increases your processing power and lower your consumption.

If you're writing processes that run on a core from start to finish, then it only uses 1/16th of the processor's power (if it has 16 cores.) So, we need a programming paradigm that supports parallelism. Concurrent programming is hard.

Making data immutable makes it so you can eliminate common problems with threading and concurrency. Read-only (immutable) Object Oriented programming is effectively functional programming. We should see this change occur over the next 3-7 years.

<strong>[00:31:05] Most of the people at Ruby conferences are using Elixir</strong>
When Dave goes to conferences about Ruby, he finds out that about 50% of speakers and many of the attendees are doing Elixir and/or experimenting heavily with it. Ruby and Rails changed the way we work, but in many ways the functional programming is changing things again. Scaling matters. We can't just throw hardware at it. You can drop your server bill by 10x or 100x.

Elixir can get you there fast like Ruby, but it can also cut costs of running your server.

<strong>[00:35:43] Is a computer science degree that way to get in? or should people get in through bootcamps or self learning?</strong>
It depends on your learning style. You do not want to get into Computer Science because your parents wanted you to have a good job. The students that get into it because of family pressure don't love what they're doing and are kind of stuck. Programming is hard enough that if you don't enjoy it you won't excel.

In any case, do what works for you. You don't need to do a 4 year course of study to be a successful programmer. Quite a few good programmers Dave knows never took a CS course. If you do a course, find out that if the teachers are doing or have done the kinds of things you want to do. The better IT shops also tend to recognize that it's the person, not what they know, that really matters. So go to them and ask to apprentice with their good programmers at a lower salary. Then if you're contributing, ask for a competitive salary.

<strong>[00:41:03] What do we as programmers assume about CS degrees that we need to change?</strong>
Don't let the HR department do the hiring. Making them happy is what gets you bogus job requirements. Instead, put together some requirements that hint that enthusiasm trumps everything else. Or, have criteria like "must be able to fog a mirror" and pick for enthusiasm. Or, go to local maker groups or users groups or community colleges where the kinds of people you want are, and talk to people. Then network into the people you want. Ignore the qualifications and pay attention to the qualities.

One of the best people Dave hired was an alcoholic chemistry teacher, but he could get into a project.

<strong>[00:45:00] You don't want a career.</strong>
Spend the next 5-10 years job hopping. You want experience, not a career. You have no idea what you want to do right now, so try lots of things. Then if it's not working move on.
<h3>Picks</h3>
<strong>Charles:</strong>
Ubuntu Bash on Windows
VMWare Workstation: <a href="https://www.vmware.com/products/workstation.html">https://www.vmware.com/products/workstation.html</a>

<strong>Dave</strong>:
Have something in your life that is relatively simple and relatively mechanical that you can fix if something goes wrong. (Dave tells us about his tractor.)

<h3>Transcript</h3>


