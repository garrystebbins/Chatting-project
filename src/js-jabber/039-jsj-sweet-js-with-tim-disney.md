---
layout: layouts/post.njk
title: >
  039 JSJ Sweet.js with Tim Disney
date: 2012-12-21 16:37:00
episode_number: 039
duration:
audio_url: https://media.devchat.tv/js-jabber/JSJ039SweetJS.mp3
podcast: js-jabber
tags:
  - js_jabber
  - podcast
---

### Panel

- Tim Disney ([twitter](https://twitter.com/disnet) [github](https://github.com/disnet) [blog](https://disnetdev.com/))
- AJ O’Neal ([twitter](https://twitter.com/coolaj86)&nbsp;[github](https://github.com/coolaj86/)&nbsp;[blog](https://coolaj86.info/))
- Jamison Dance ([twitter](https://twitter.com/jergason)&nbsp;[github](https://github.com/jergason)&nbsp;[blog](https://jamisondance.com/))
- Joe Eames ([twitter](https://twitter.com/josepheames)&nbsp;[github](https://github.com/joeeames)&nbsp;[blog](https://www.testdrivenjs.com/))
- Tim Caswell ([twitter](https://twitter.com/creationix/)&nbsp;[github](https://github.com/creationix/)&nbsp;[howtonode.org](https://howtonode.org/))
- Charles Max Wood ([twitter](https://twitter.com/cmaxw)&nbsp;[github](https://github.com/cmaxw)&nbsp;[Teach Me To Code](https://teachmetocode.com/))

### Discussion

01:23 - Book Club Episode: [Effective JavaScript by David Herman](https://effectivejs.com/)

- Episode will record on January 10th and air January 18th
  01:48 - [Sweet.js](https://sweetjs.org/)
- Macros: syntactic transformations
- Build-your-own [CoffeeScript](https://coffeescript.org/)
- Cleans up code
  07:03 - Benefits and Disadvantages 10:37 - Using Macros
-

Where are they needed? Where are they not needed?

- [Why sweet.js Matters](https://jlongster.com/why-sweet.js-matters)
  13:10 - Pattern Matching 15:36 - Domain Specific Languages 16:48 - Hygiene 18:50 - Class Macro 20:28 - Limits 21:38 - Language Support 25:18 - Nesting 28:40 - Cool Macros
-

[Example macros](https://github.com/mozilla/sweet.js/wiki/Example-macros)
30:13 - Sweet.js: What is coming?

- Defining Macros
- Syntax Rules
  33:06 - [Sweet.js mailing list](https://groups.google.com/forum/#!forum/sweetjs)
- IRC channel #sweet.js on irc.mozilla.org

### Picks

- [Google+ Hangouts](https://www.google.com/+/learnmore/hangouts/) (AJ)
- [The Man from Earth](https://www.imdb.com/title/tt0756683/) (Jamison)
- [TypeScript](https://www.typescriptlang.org/) (Joe)
- [Red Dawn](https://www.imdb.com/title/tt0087985/) (Joe)
- [Creationix Innovations](https://creationix.com/) (Tim C.)
- [Effective JavaScript by David Herman](https://effectivejs.com/) (Tim D.)
- [Growing a Language by Guy Steele](https://www.youtube.com/watch?v=_ahvzDzKdB0) (Tim D.)
- [Downton Abbey](https://www.pbs.org/wgbh/masterpiece/downtonabbey/) (Chuck)
- [Rails Ramp Up](https://railsrampup.com/) (Chuck)

### Transcript

**JAMISON:** &nbsp; Oh, my goodness! You can like, put a beard on them and it follows their face! **JOE:** &nbsp; Isn’t that awesome? [Crosstalk] **JAMISON:** &nbsp; How do I get rid of it? Actually, it was really distracting. I didn’t know you guys would see that. **_[This episode is sponsored by Component One, makers of Wijmo. If you need stunning UI elements or awesome graphs and charts, then go to [Wijmo.com](https://www.widgemo.com/) and check them out.]_** **_[Hosting and bandwidth provided by the Blue Box Group. Check them out at [Bluebox.net](https://www.blueblox.net/).]_** **CHUCK:&nbsp;** Hey everybody and welcome to Episode 39 of the JavaScript Jabber show. This week on our panel, we have AJ O’Neal. We have AJ O’Neal on mute. We have Jamison Dance. **JAMISON: &nbsp;** I am not on mute, I hope. **CHUCK:&nbsp;** We have Joe Eames. **JOE:&nbsp;** Hi everybody. **CHUCK:&nbsp;** We have Tim Caswell. **TIM C:&nbsp;** Hello. **CHUCK:&nbsp;** We also have a special guest, that’s Tim Disney. **TIM D:&nbsp;** Hi. **CHUCK:&nbsp;** AJ, did you figure out your mute issues? That would be a no. I’m Charles Max Wood from [Devchat.tv](https://www.devchat.tv/). And this week, we’re going to be talking about Sweet.js. Before we get started, there is one thing I want to announce really quickly and that is that we have scheduled a Book Club episode for January 10<sup>th</sup> and that’s going to be with David Herman who wrote ‘Effective JavaScript’. So it’s a pretty slim book, should be easy to get through. But yeah, if you want to follow along with that discussion, then by all means, join in. Alright. Let’s talk about Sweet.js. Has anyone… **AJ:&nbsp;** Can you hear me now? **CHUCK:&nbsp;** Yeah. **AJ:&nbsp;** Okay, cool. **CHUCK:** &nbsp;So, I went and looked at it. I fiddled with it a little bit. I didn’t have enough time to really get into it the way that I wanted to. It looks really cool though. What kind of gave you the idea of doing something like macros for JavaScript, Tim? **TIM D:** &nbsp;Well, I guess it’s just something I’ve sort of wanted for JavaScript for awhile. But the main sort of impetus I guess was, I was interning at Mozilla Research this past summer. And Dave Herman who has worked on macros in the past basically said he thought that it was sort of finally possible to do for JavaScript. And so, that was a possible sort of intern project for the summer. And so, that’s what got it started. **JAMISON:&nbsp;** So can you back up and talk about what macros are, because I’m sure there are lots of people that don’t know and lots of people that hear macros and think like CP process are macros. **TIM D:** &nbsp;Right yeah, exactly. So, C style macros are the sort of painful and sort of limited. The macros that Sweet.js implements are much more in line with sort of scheme style macros. So, what this means is it basically allows you to do syntactic transformations on your source code. So basically, you can build sort of lightweight language extensions into your language. It’s a basic idea, I guess. **CHUCK:&nbsp;** So, is this not something that you could just do by writing functions that extend things in the same way? **TIM D:&nbsp;** Right, exactly. So the idea of macros are to do the sort of static things that only can happen at compile time and not do the sort of dynamics sort of abstractions that you do with just normal functions. **CHUCK:&nbsp;** I’m not sure I completely follow what the difference is. Do you want to explain a little bit more? **JAMISON:** &nbsp;Maybe like an example. **CHUCK:** &nbsp; Yeah. **TIM D:** &nbsp;Yeah, definitely. Well, one thing you might want to do is add classes to a language, to JavaScript. So, that’s a syntactic sort of thing. So like CoffeeScript for example, has sort of class syntax for it and it compiles down to just using normal prototypes and what not. In JavaScript, you’re just hooking things up. But you know, you can actually write class and then constructor and all your different methods. And so, you can write a macro that does just that, as in sort of class syntax, that then gets compiled down to just functions and hooking up prototypes and doing that whole thing. **AJ:&nbsp;** So, it’s like build your own CoffeeScript? **TIM D:** &nbsp;Exactly, yeah. It’s build your own CoffeeScript and it allows you -- so whereas with CoffeeScript, you have to sort of buy into all of CoffeeScript. You have to have this one compiler that just does CoffeeScripts and all of your code has to be written in CoffeeScripts. So that the hope with macros is that you can write sort of individual pieces that you want, and then compose them. So, a bunch of different people can say, “Make a class macro or make a var de-structuring macro.” And then they work together and you don’t have to have just one compiler that does just like CoffeeScript. **AJ:** &nbsp;Very cool. **CHUCK:** &nbsp;Yeah. One thing that I really like about the approach is that it can really, really clean up your code because effectively, you just have one representation for the structure that you need there and you just create it with a macro and make it work. **JAMISON:** &nbsp;Yeah, exactly. **TIM C:&nbsp;** So how powerful is the parser this thing uses? Like I wrote the initial parser for CoffeeScript using Jison and that language is insanely context sensitive. Like could you actually do CoffeeScript as it exists today using this or is it not strong enough? **TIM D:&nbsp;** So probably at the moment, we can’t. We’re going to get more powerful eventually there is a few things that we need to sort of add. But it’s never going to quite give you the same sort of power as just using a full on grammar like of Bison and all that. And that’s not what it’s trying to do. It’s trying to say, “Here’s the basic sort of things that you want to be able to do,” in a nice abstraction sort of way. So at the moment, what that means is you have to have the macro name. So in your macro invocation syntax, you have to have a macro name followed by some number of tokens, some bits of syntax. So then, you can match on that and then do your transformations of that. So, that’s sort of the limitation at the moment. **CHUCK:&nbsp;** So when you’re talking about macros, this isn’t hooking into the same functionality that you used to define functions. This is actually, you keep saying compile, are you relying on some kind of Git compiler or something in the VM? **TIM D:&nbsp;** No, no, no, no. So Sweet.js as it exists right now is totally an offline compiler or transpiler, whatever term you want to use there. So we are built on top of Esprima and so you take in your JavaScript source plus macros, the Sweet.js source code and then you pass it through Sweet.js which compiles out all the macros and spits out just pure JavaScript. And then you run that. So it’s a static sort of compile time thing that happens. **JOE:&nbsp;** Are there other benefits and disadvantages to using this versus a real transpiled language like CoffeeScript or TypeScript? **TIM D:&nbsp;** Yeah. So, the benefit of using something like or the benefit of doing something in CoffeeScript or TypeScript is that you have more sort of low level power of making whatever language you sort of want. The big benefits of macros is that it’s really easy to actually write your macros, add your syntactic abstractions or whatever, lots of macros you can write in like five lines of code or something like that. So, it sort of lowers the barrier of starting to write basically new languages. And then the other thing is this composability idea, whereas with CoffeeScript, you have to buy all the way into CoffeeScript. But with macros you can sort of pull in different macros that are written without having to think about one another. So, they just work together. **JOE:&nbsp;** So what’s your take on TypeScript? TypeScript is a little bit easier under the CoffeeScript? **TIM D:&nbsp;** Yeah, TypeScript is pretty cool. I haven’t played around with it too much so I can’t really say too much about it. **JOE:&nbsp;** Is it pretty easy to use macros that come from other sources and not have it walk over stuff that you’ve already done? **TIM D:&nbsp;** Yeah. That is one of the things that macros work really well is that they can work together. So, I don’t think you have to do too much thinking when you’re writing your macros and they just work together. **JOE:&nbsp;** What about like name spacing and overriding of macros and stuff? **TIM D:&nbsp;** So, what do you mean by there? **JOE:&nbsp;** So like, if I write a class macros and [inaudible] of class macros and I want to use them both but they both have the same name, how do I resolve that? **TIM D:&nbsp;** So right now, the only way that you can share macros is just copying and pasting them into your code. But eventually, Sweet.js will work with -- we’re going to build on top of ES6 macros, not macros, modules. So you’ll be able to share macros via modules and then that name spacing via modules will work that way. **CHUCK:&nbsp;** One thing that strikes me when you’re talking about whether or not you can share macros, and the only way to do it right now is to copy and paste them in, is that this would be a very powerful abstraction to use for giving you a certain language or language constructs that you wish you had and then being able to share them. So is there -- are you looking toward a way to make this so that you can just plug it into your global or into a set name space so that you can then use it across the board wherever you’re at? **TIM D:&nbsp;** Yeah, absolutely. So, the way you do it right now is you write a bunch of macro definitions basically at the top of your file and then all of those macros are available to be used across your code. And then eventually, like I said, they will work with modules so you can share it across your entire code base. **CHUCK:&nbsp;** So, is there anyway that you could, for example, include or require Sweet.js and then include or require a file full of macros? Would that work? **TIM D:** &nbsp;Yeah, exactly. So when I said building on top of modules, at the moment, it doesn’t work. But we will get it working eventually. You would basically write up your class macro or whatever. And then, you would say, in whatever file that you want to use it, you would say import, require, whatever from my file full of macros, the class macro. And I just wan to use that here and pull it in. **JAMISON:** &nbsp;So, I wanted to talk a little bit about how to use these in a project without driving yourself or other people insane. Because I know in C projects, they use lots of pre-processor macros. You end up creating like your own dialect of C and things that look simple can turn out to be really complex and you have to go -- it’s really hard to tell what’s actually going on and especially for new people coming in. Do you have any strategies for how to use macros wisely, so they save you time instead of understanding your code a lot harder? **TIM D:** &nbsp;Yeah, the big thing is doesn’t use macros when they’re not actually needed. So, don’t use them excessively, I guess, is one thing. As far as… **CHUCK:&nbsp;** I want to back up there really quickly because what you just said was, I’m going to wave my hand at this, “Don’t use them where they’re not needed.” Where are they needed and where aren’t they needed? I’m sure there’s some gray area, but where is it that you’re really going to shoot your foot off if you use them? **TIM D:** Yeah. So, you’re really going to shoot your foot off if you try and use them where a function works better. So in other words, where you don’t actually need the nice syntax. So in other words, you can basically use a macro sort of like a function, doing a functions job. But if there’s not really a good reason to do that, I am sort of hand waving here. I don’t have a great way of saying that. **JAMISON:&nbsp;** That makes sense. I mean, it seems like that you could get very excited by macros and start using them everywhere. And what you’re saying is avoid that. And if there’s something you just do with a function, just do it with a function. **TIM D:&nbsp;** Right. Yes. Exactly. **CHUCK:&nbsp;** So then, what is the difference between a function and a macro? I get that a function, you call it and it executes stuff and you have a pointer to it so you can pass it around. With a macro, it looked like it was almost setting up. It was doing some kind of, I’m trying to think, it was like building syntax or something. I’m not sure if that’s the right term. **JAMISON:&nbsp;** Yeah. It kind of adds new syntax to the language. Like, I’m looking at some examples and there’s one that adds de-structuring assignment to JavaScript. So, that’s the thing in CoffeeScript where if you have an object, you can just pluck things out of the object and assign them to variables in your scope easily. And somebody just did that in a macro. But it’s not a thing you could do with a function in JavaScript. It’s like new syntax. **TIM D:&nbsp;** Exactly, yeah. **TIM C:** &nbsp;Could you talk about the pattern-matching feature? I know not all macros have this. **TIM D:&nbsp;** Yeah, yeah. So the pattern matching -- this is basically the way it works is when you’re defining your macro, you basically say, “Okay. So my…” For example, we can actually use the var de-structuring example. So, a ‘de-structure’ is something that starts with say, the keyword var and then say, is followed by, I don’t know, if you’re going to want to de-structure an array. Say for example, you’d say, open bracket, then some number of identifiers, then close bracket, equals some expression. And so, you just write that out in your macro definition. It would be literally, you know, var open bracket, some characters, and then close bracket. What would happen is that basically matches the syntax. And then in your macro body transformation, you can refer to the things that you matched and then put them in the right sort of place in your template. So basically, you’re pattern matching on syntax and then emitting some template with the things that you matched. **TIM C:&nbsp;** I’m seeing here that you’ve types on some of these, like I guess that’s a JavaScript identifier. **TIM D:&nbsp;** Yes. Yeah. So, those aren’t -- they're not really types there. They’re basically parse annotations. So, the colon ident is saying, match me an identifier. We also have things like match me an expression, match me a statement, things like that. What that actually uses is it uses the parser as Prima parser down under the covers to pull in, to actually do that sort of pattern matching on real expressions. So, you don’t have to basically rewrite an expression grammar. Does that make sense? **TIM C:&nbsp;** Yeah. One of the things we were doing at Cloud 9 was we had the AST, I think it was the tree hugger project and people could write plug-ins to modify the AST but this is a very different level. This is kind of syntax-oriented, it seems. **TIM D:&nbsp;** Yes. Absolutely. Yeah, the things that you are matching are pieces of grammar. **CHUCK:&nbsp;** So, one other use that I see for this is something that I see a lot in Ruby and that is domain specific languages, where you could actually create your own syntax for pulling something apart basically giving it a way to parse a file. And on the other end, you effectively get executable JavaScript. **TIM D:&nbsp;** Yeah, absolutely. That’s sort of -- yeah, there is a couple of ways of using macros. One is to just give you some sort of convenient syntax, and the other is sort of going all the way to making a domain specific language that does all kinds of crazy sorts of things that is appropriate to your specific domain. So yeah, absolutely. **CHUCK:&nbsp;** Yeah. I just see stuff like that used for configuration files. I’ve seen it used for testing. I mean, it’s very powerful when you can do that kind of thing and just give it, “I see this. I expect this.” And it just builds it out and makes it all nice and pretty. **TIM D:&nbsp;** Yeah. And then a nice thing with macros is that this is much easier to sort of get started with that. You don’t have to think about the whole grammar and things like that. You just start building a bunch of macros. **JAMISON:&nbsp;** So, can you talk about the hygienic part too because a big part of the pitch is that they’re hygienic macros and I had to look on Wikipedia to see what that was. But it seems like a pretty cool thing. **CHUCK:&nbsp;** &nbsp;They brush their teeth and wash their hands. **TIM D:** &nbsp;[Laughs] Yeah, exactly. So, hygiene is this term that comes out of scheme and the idea is, it’s basically protecting your abstractions. So, if you were writing say, an ‘or macro’ and an ‘or macro’ is just something that -- excuse me, swap, swap macro. And swap is where you’re going to take two variables and then just swap them, right? Take the contents of one and put them in the other. And the way you would normally do this is you would say, put the value of like A into a temp and then -- so you have to have three variables that you sort of move back and forth between them. So, what your macro does is it introduces this extra temp variable and if you’re not careful you have to figure out what you’re going to name that temp variable. And the problem is that if you’re not careful, that name might clash with something else in your code. And so what hygiene is, it just says, “The things that you introduce with your macro will not clash with other things.” Any sort of identifiers or variables that you introduce with your macro, will be renamed appropriately. And yeah, it turns out the algorithms are like really complicated and crazy because there are all these edge cases and stuff like that that is very hard to understand. But, yeah. So, we do hygiene which is really important with macros because otherwise, if you don’t have hygiene, things sort of step on top of each other especially when you have a bunch of macros that you’re trying to have work together. Like if different people write different macros, you need a mechanism under the covers that sort of makes sure that they don’t step on one another’s. **JAMISON:&nbsp;** That seems really useful because I mean, I keep talking about this CPU processor and I know it’s totally different but if you&nbsp; just did text replacement and you could get all kinds of messed up results. So, that’s cool. **TIM D:&nbsp;** Yeah, exactly. **CHUCK:&nbsp;** So, I’m looking at your example here for the class macro. And I have two questions. The first one is that class is a reserved word in JavaScript, is it not? **TIM D:&nbsp;** It is, yes. **CHUCK:&nbsp;** So, do you get all kinds of headache and you know barbarian hordes coming down on you if you do that? **TIM D:** &nbsp;[Laughs] Yeah, possibly. So, the class is a future reserved keyword or whatever, right? Because it’s not used in JavaScript at the moment, but it will be in ES6. So, one nice thing with these macros is it allows you to sort of do polyfilling of future syntax changes that are coming in, in new versions of the language. So, with class, now you have to use ES6. You have to have some environment that you just use ES6. But now, you could write a macro that does the same thing and serve, you know, a normal ES3 or ES5 or whatever, environments that need it while still writing, while still using the class syntax. **JAMISON:&nbsp;** &nbsp;But could you use this for something like the ES6 module specs that they’re working on? **TIM D:&nbsp;** Yeah. I don’t think you can use macros to do modules. I think there are sort of technical reasons that don’t allow that. **TIM C:&nbsp;** Turn them into AMD or something. I don’t know, maybe. **TIM D:&nbsp;** Yeah maybe, I’m not sure. I suspect not, but yeah. You can definitely take a crack at that. **CHUCK:&nbsp;** If you realize by saying that, somebody’s going to get on and try to prove you wrong, right? **TIM D:&nbsp;** Yes, no. That would be great. [Laughs][crosstalk] **JAMISON:&nbsp;** So, what are the limits of it? I don’t have a good handle on how they work. So, I’m sure there are things you can’t do even with macros. But what are those kinds of things and how do you identify something? **TIM D:&nbsp;** So obviously, you can’t make any changes that will sort of happen at runtime. This is just static sort of changes of the syntax. So, if you can’t imagine transforming it to some other sort of code, then it won’t work there. So at the moment, the sort of form is limited. So you have to start with an identifier followed by some amount of strings, if that makes sense. You can’t put the name of a macro in the middle of two different -- it can only match after a macro name, if that makes sense. Eventually, we’ll try and expand that as well so that you can do sort of infix macros, stick a macro between. So, you could basically add new binary operators so macros could act as sort of a binary operator sort of thing. So that’s a limitation we have now. We might be able to address some of that but that’s probably part of it, I guess. **TIM C:&nbsp;** On language support. So, your compiler run time, is that a node module? Does it run on the browser as well? **TIM D:&nbsp;** Yeah. So, it runs both on node and in the browser. **TIM C:&nbsp;** Does it use ES5 or does it -- will it run on any browser? **TIM D:&nbsp;** It should run on any browser, as far as I know. I haven’t tested it everywhere but I don’t think we’re using anything weird. So, the bit end of browser, we’re using AMD. So, you can do AMD loaders. So, you can write your module with macros and then require it from somewhere else and it will automatically compile that down in the browser, which is nice. **JAMISON:&nbsp;** That’s sweet. **AJ:&nbsp;** Oh, gosh! **JAMISON:&nbsp;** Oh, no! **TIM D:&nbsp;** The puns. [Laughs] **JAMISON:** &nbsp; Oh, yeah. I thought they’d never end. **TIM D:** &nbsp; Yeah. [Laughs] **CHUCK:&nbsp;** Hey, we only had one Disney joke. **JAMISON:&nbsp;** Sure. We went easy on you. [Laughter] **CHUCK:&nbsp;** So, one other thing that I’m looking at here, I’m looking at the example of building the class. My other question was, is there a way it looks like it’s just, here’s a constructor and here’s a function. But I guess my question is can you set it up so that it will accept an unknown number of functions or methods on the class? **TIM D:&nbsp;** Yeah, absolutely. Actually, if you’re looking on the home page you’ve got, I think that one accepts any number. Yeah, it does. So, if you see the ‘…’ at the end, we’re matching a bunch of method names. And then the ‘…’ at the end says match any number of them. **CHUCK:&nbsp;** Oh, okay. **TIM D:&nbsp;** So, it’s like star or whatever. So, the macro defined right there supports any number of methods that you write in the class and then, it expands it any of those numbers. **TIM C:&nbsp;** Are there docs saying what all the various units you can match against are. Because I see here param is a unit. But I mean, an elixir, that can be many tokens. **TIM D:&nbsp;** Sorry. I’m not quite following what you’re asking. **TIM C:&nbsp;** Right. So, I’ve assumed it’s matching against some sort of AST that’s being parsed by Esprima, you said? **TIM D:&nbsp;** Yes, yes. **TIM C:&nbsp;** So, how do we know that the entire body of the method is one thing and the entire parameter list is one thing? How we do know what the units are that we match against? Do we just play with Esprima and see what it outputs? **TIM D:&nbsp;** So, you mean when we say things like colon ident or colon exper? **TIM C:&nbsp;** Yeah. So, here in the class where you’ve got method name ident, so that’s going to match one string. But then you got method param which I guess it the entire parameter… **TIM D:&nbsp;** Oh, I see. Yeah, yeah, yeah. So, if it doesn’t have a colon class name at the end, then that’s just going to match one token. And what we mean -- so, it’s not quite the same token that you might expect. It’s going to match either things like an identifier or string or it’ll match actually whole groups of delimiter matched things. So if I have -- so yeah, with that class example, we have method param and that’s actually matching the entire begin paren, all the tokens inside, close paren. So that sort of counts as one token. **AJ:&nbsp;** We should probably just clarify, the class example is the one on just the [Sweet.js.org](https://www.sweet.js.org/) website, right? You just scroll down. **TIM D:&nbsp;** Yes, exactly. **AJ:&nbsp;** Okay. **CHUCK:&nbsp;** Yeah, that’s what we are looking at here. My question is then in JavaScript, and I’m assuming in these macros, you can nest stuff within the curly braces. So, how does that nesting work? **TIM D:&nbsp;** Sorry. Again, I’m not quite following. **CHUCK:&nbsp;** So for example, in the class example, you have a function in a class or a method on a class, what if you just have an anonymous function inside of another anonymous function or something like that? **TIM D:&nbsp;** Inside of … **CHUCK:&nbsp;** So then, you have the overall token and then inside of that, you have stuff that could also then be tokens. **TIM D:&nbsp;** Yeah, exactly. So, if you’re matching -- if you’re talking about like matching inside of the method body which is this sort of the curly matched stuff. There could be -- so sort of internally to Sweet.js, the way we sort of match tokens is anything that is delimiter match might have sub-delimiter match things, so you build out a tree. In terms of actually writing it, you don’t notice that too much. You just match the outer sort of delimiter match thing. You could have any sort of nesting that you want going on there. **CHUCK:&nbsp;** How do you drill into that, because I’m not sure I’m seeing it here? **TIM D:&nbsp;** Yeah. The way you drill into it is you would have to match it in your patterns. So for example there, if you wanted to explicitly match something inside of the method body, you would have to start out with the curlies then match some stuff inside and then… **CHUCK:&nbsp;** Okay. So, you’re going to get the syntax that you expect and then it’ll match everything according to what it sees that lines up with it. **TIM D:&nbsp;** Exactly, exactly. **CHUCK:&nbsp;** So, does that mean then that you can’t match the outer thing and the inner thing as two separate entities? I don’t know why you would need to but… **TIM D:&nbsp;** Yeah, exactly. You wouldn’t be able to match both at the same time. But yeah, you wouldn’t need to because you already know the tokens that you’ve matched so that you can just recreate them in the macro body. **CHUCK:&nbsp;** Okay. Yeah. This is just really, really interesting. I’m kind of with Tim on this, I’m not seeing terrific documentation. I see examples but I don’t see documentation. **TIM D:&nbsp;** [Laughs] Yes. This is an unfortunate truth, definitely something that I need to work on. **CHUCK:&nbsp;** Or somebody else who wants to be involved can jump in and work on it. **TIM D:&nbsp;** Absolutely. That would be fantastic. We would love some contributors to help write that out. **AJ:&nbsp;** Who is we? You keep saying ‘we’ when you talk about it. **TIM C:&nbsp;** Yeah. So, it’s mostly just me at the moment.[Laughter] **AJ:&nbsp;** The royal ‘we’. **TIM D:&nbsp;** Yes, the royal ‘we’. [Laughter] **CHUCK:&nbsp;** His last name’s Disney. They’re famous for royalty. It just works. [Laughter] **TIM D:&nbsp;** Exactly, exactly. While I was an intern over the summer, I worked with Dave Herman a little bit and then Paul Stansifer who is a fellow grad student. But now, it’s mostly just me working on it on my spare time. **CHUCK:&nbsp;** So, what are you doing now, just school? **TIM D:&nbsp;** Yeah, school. I am a grad student.&nbsp; **&nbsp;** **CHUCK:&nbsp;** And where are you at? Were you working with the folks in Mozilla up in, is it Toronto? **TIM D:&nbsp;** No, in Mountain View. I’m at UC Santa Cruz right now. **CHUCK:&nbsp;** Oh, cool! **JOE:&nbsp;** So, what are some of like the coolest macros you’ve seen people write, that you were just like, “Wow! I had no idea that what I built could do this.” **TIM D:&nbsp;** Right. One of them was actually Haskell style do-notation. Somebody wrote -- we’ve got a link to it on our Sweet.js wiki. We have a bunch of example macros. But yeah, somebody started doing [inaudible] do-notation type of stuff. And I was like, “Whoa! That’s a little crazy.” **CHUCK:&nbsp;** Yeah, I think I’m going to make it so I can write Ruby in JavaScript. **TIM D:&nbsp;** Yeah. [Laughter] **CHUCK:&nbsp;** And I’m not serious. **AJ:&nbsp;** Oh, there are plenty of people working on that. **JOE:&nbsp;** It’s already solved. We have CoffeeScript. [Laughter] **CHUCK:** I was waiting for somebody to say that. **TIM C:&nbsp;** &nbsp;And that guy actually did that Ruby standard library thing too. **CHUCK:&nbsp;** Yeah, somebody was working on that. I don’t remember what it was called. **TIM D:&nbsp;** A digression. **CHUCK:&nbsp;** &nbsp;So, what is your -- are you doing Masters or Doctorate or what? **TIM D:&nbsp;** &nbsp;Yeah, PhD. **CHUCK:&nbsp;** PhD. And what is your Doctoral , is it a thesis or a dissertation? **TIM D:&nbsp;** &nbsp;Yeah, thesis, dissertation, whatever you want to call it. Yeah. **CHUCK:&nbsp;** What are you going to dissert on? **TIM D:&nbsp;** &nbsp;We’ll find out. I'm sort of working on a thesis proposal now. So, I have a few years to go left. It’ll be some sort of PL semantic type stuff that I’ll be doing. Still trying to nail down exactly what it is. **JAMISON:&nbsp;** So to go back to the macro stuff in Sweet JS, you’ve talked about it a little bit when we’ve just talked about specific features. But where do you imagine this is going next? What will be coming? **TIM D:&nbsp;** &nbsp;Coming in terms of Sweet.js? **JAMISON:&nbsp;** Yeah. **TIM D:&nbsp;** So in the very short term, hopefully lots of bugs will be fixed. But eventually, there’s sort of -- one big thing that I want to get in is a more imperative way of defining macros. So right now, the way you define macros is this very rules based sort of thing. You match these sorts of things and then you basically have this template that you emit. **JAMISON:&nbsp;** Yeah. It feels like a grammar, kind of. **TIM D:&nbsp;** Yes, to a certain extent, like a grammar. So in Scheme, the thing we want to do is called Syntax Rules. And basically, the way this is, is you can actually write just normal JavaScript in your macro body that can manipulate the syntax that you just matched. And just use normal JavaScript or whatever to manipulate it, change it or whatever, and then emit that. **JAMISON:&nbsp;** That is cool. **CHUCK:** That would be way cool. **TIM D:&nbsp;** Yeah. So, that’s one of the things that’s hopefully coming pretty soon. **JAMISON:&nbsp;** What did you call that? Syntax Rules? **TIM D:&nbsp;** Syntax Rules is what the Scheme world knows it as. **JAMISON:&nbsp;** I think I can Google and read about it. **TIM D:&nbsp;** Yeah, exactly. **JAMISON:&nbsp;** Sweet! **TIM C:&nbsp;** So basically, you just get an access to some object that has AST methods and you can do things with it. **TIM D:&nbsp;** Yeah. Technically, they’re not AST methods. So, an AST would be the finalized sort of thing. The thing that you’re getting is really just this un-interpreted sort of tree thing, but really just a bunch of tokens. **TIM C:&nbsp;** Okay, so a different level. **TIM D:** &nbsp; Yeah, exactly. **CHUCK:&nbsp;** Interesting. We should really get somebody on to talk about AST’s, Grammars, and stuff like that. **JAMISON:&nbsp;** Yeah. They’re good stuff. I could say that word, it’s as far as I get. **CHUCK:&nbsp;** So, are there any features of the macros that we haven’t covered or any that you just think we haven’t given enough attention to that are awesome? **TIM D:&nbsp;** No. I think we probably covered most of it, yeah. **JAMISON:&nbsp;** This looks really cool. Do you know any projects that are using this in production? **TIM D:&nbsp;** I don’t. And I hope no one is using it in production at the moment. [Laughter] **TIM D:&nbsp;** It’s still very early stages with lots of bugs and things. But yeah, I have big hopes for it. **JAMISON:** &nbsp;Cool! **CHUCK:&nbsp;** Nice. So, are they still working on it over at Mozilla? Or is it mostly you? **TIM D:&nbsp;** No, it’s just me. **CHUCK:** &nbsp;So, “I interned at Mozilla and all I got was this lousy project?” [Laughter] **TIM D:&nbsp;** Yeah, something like that. **JOE:&nbsp;** So, are there any community sites that have sprung up around Sweet.js that are providing a lot of content in addition to the actual Sweet.js site that you really think are great and would like to point people at? **TIM D:&nbsp;** So, we’ve got a mailing list, IRC channel, things like that but nothing else that’s really sprung up yet. **JAMISON:&nbsp;** Yeah. We’ll put links of those things in the show notes. **CHUCK:** Alright. Well, if we’ve covered it, then we’ll go ahead and get into the picks. I’m going to start all the way on my left with this video thing which is kind of cool. We’ll make AJ go first. **AJ:&nbsp;** Alright. I’m ready for you. My pick is Google+ Hangouts. This has been kind of cool, I haven’t done this before. **CHUCK:&nbsp;** Yeah, it’s interesting, it will be posted too as soon as I click end broadcast. It will be on YouTube. **JAMISON:&nbsp;** Yeah, you can get a sneak preview. **AJ:** &nbsp; Also, I’m a big fan of all algorithms that reduce big O of in, to big O of log-in. I’m going to pick all of them. [Laughter] **JOE:&nbsp;** Binary search for the win! **JAMISON:&nbsp;** Shout out to my homies! **CHUCK:&nbsp;** Alright. Jamison, what are your picks? **JAMISON:&nbsp;** Mine is a movie called, ‘The Man from Earth’. It’s kind of a Sci-Fi movie, sort of. It’s a little weird because it’s basically only about one character but it’s really well-done. It’s basically all about this one character and looking at his long and varied life and it’s really cool. So, you should check it out. I have never heard of it before I saw it and it was really good. So, ‘The Man from Earth’. That is it. **CHUCK:&nbsp;** Awesome. Joe, what are your picks? **JOE:&nbsp;** Alright. So for my first pick, I want to pick Typescript. We actually had a demo talk at the Utah JavaScript Users Group last week. And the guy who presented it gave a really good presentation, showed it, and I was really impressed. I was already impressed with it before but after seeing it, I was really super impressed. Just how nice it is, you can mix it in without committing to it, just where you want. I really was very, very, very pleased with what I saw in Typescript. So, I want to pick Typescript for my first pick. And then, I went recently and saw the movie Red Dawn. And so, I would like to pick the original Red Dawn and not the one that just came out. [Laughter] **JOE:** &nbsp; I noticed it was on Netflix and so I watched it again and remembered how great that movie was and in contrast to the new movie, how terrible the new movie is. So, I want to pick the original Red Dawn and those are my picks. **AJ:&nbsp;** It didn’t get a green splat on Rotten Tomatoes for nothing. **CHUCK:&nbsp;** Alright. Tim, what are your picks? **TIM C:&nbsp;** Unless you follow me on Twitter, you might not have heard that I now am an independent consultant. And so, I’m going to cheat and self-promote. So, if you have any node or JavaScript projects that you want help on, I am available to work on those. And also, I’ve spent the last couple weeks writing a Lua VM in JavaScript which is really, really hard. **AJ:&nbsp;** And really awesome. I’ve used it. **TIM C:&nbsp;** I don’t know if it will be valuable but it’s fun and I’m learning all of that hard stuff. **JAMISON:&nbsp;** It seems like you love the really, really hard things. That’s cool. **TIM C:&nbsp;** Got to do something. [Laughter] **JAMISON:&nbsp;** How would people contact you if they wanted to give you lots of money to help them? **TIM C:&nbsp;** If you want to give me lots of money, you can Email me. My Email is on GitHub or my website, [Creationix.com](https://creationix.com/). **CHUCK:&nbsp;** Awesome. Alright Tim, what are your picks? **TIM D:&nbsp;** So, it sounds like you guys are actually going to talk about it in a bit, but Effective JavaScript, the book. Just read that a few days ago and it’s fantastic. So, definitely check that out. **JAMISON:** &nbsp; Yes, it is a great book. **TIM D:** &nbsp; Then also, there was a great talk that I don’t think enough people have seen called ‘Growing a Language’. This was a long time ago, about ‘98 or something like that, by Guy Steele, talking about how to grow a language. So if you’re interested in language sort of things and language design, definitely check that out. **CHUCK:&nbsp;** Alright. I’m last, I guess. My first pick is a show that I’ve been watching with my wife, I was a little surprised at how much I liked it, it’s called Downton Abbey. It’s a masterpiece classic show. It takes place right before and then during World War I. But the thing that’s really interesting to me is just all the historical things there. So, they just installed electricity in their house and then they get a telephone. And so, some of the things that happened there, it’s like I can’t imagine living without these things. And they have the really primitive versions of them. And then, the political things and the way that England worked at that time. I’ve really, really been enjoying it. As well as the personal interplay obviously between the characters, which is what most of the show is about. My other pick, I’m going to go down the same vain as Tim and do a little bit of shameless self-promotion. I am going to be putting together -- in fact, I am putting together a Ruby on Rails course. It’s called Rails Ramp Up. You can get there at [RailsRampUp.com](https://railsrampup.com/). You can’t get there right now but you will by the time the show airs. And you can just pick and choose which sessions you want to sit in or you can get all of the sessions. The sessions are going to be a mix of instruction and live coding. Hopefully, you’ll be able to understand the concepts and then I’ll be able to walk you through them and then give you some assignments that will help you learn Ruby on Rails. So if you want to learn Ruby on Rails, I know this is a JavaScript show, then go check it out at [RailsRampUp.com](https://railsrampup.com/). And other than that, I just want to remind everybody that we are reading Effective JavaScript. We will be talking about it on January the 10<sup>th</sup>, unless it gets moved because I’m going to be out of town. So, go check it out, go buy it, go read it. I think it just came out, though. **JAMISON:&nbsp;** Yeah. It was a few days ago that it got released. **CHUCK:&nbsp;** Yeah. So, you probably haven’t seen it on store shelves or anything yet. **JAMISON:&nbsp;** It’s super good, sneak preview. It’s one of the best JavaScript books I’ve read. **CHUCK:&nbsp;** Alright, cool. Well, that’s it. I guess we’re done.
